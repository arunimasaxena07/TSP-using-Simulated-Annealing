# -*- coding: utf-8 -*-
"""EEC289_HW-3_922850642.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ACapwltlwkP5ssaTLWn1yM3ywwaFg3T7
"""

import numpy as np
import random
import math

def read_data(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()

    data = []
    for line in lines:
        parts = line.split()
        data.append((int(parts[0]), int(parts[1]), float(parts[2])))
    return data


def calculate_total_distance(tour, distances):
    total_distance = 0
    for i in range(len(tour) - 1):
        total_distance += distances[tour[i] - 1, tour[i + 1] - 1]
    total_distance += distances[tour[-1] - 1, tour[0] - 1]  # Return to the starting city
    return total_distance

def generate_initial_solution(num_cities):
    return list(range(1, num_cities + 1))

def get_neighbor_solution(current_solution):
    neighbor_solution = current_solution.copy()
    rand1, rand2 = random.sample(range(len(current_solution)), 2)
    neighbor_solution[rand1], neighbor_solution[rand2] = neighbor_solution[rand2], neighbor_solution[rand1]
    return neighbor_solution

def acceptance_probability(current_energy, new_energy, temperature):
    if new_energy < current_energy:
        return 1.0
    return math.exp((current_energy - new_energy) / temperature)

def simulated_annealing(distances, initial_temperature=1000, cooling_rate=0.99, iterations=10000):
    num_cities = len(distances)
    current_solution = generate_initial_solution(num_cities)
    current_energy = calculate_total_distance(current_solution, distances)

    best_solution = current_solution
    best_energy = current_energy

    temperature = initial_temperature

    for _ in range(iterations):
        new_solution = get_neighbor_solution(current_solution)
        new_energy = calculate_total_distance(new_solution, distances)

        if acceptance_probability(current_energy, new_energy, temperature) > random.random():
            current_solution = new_solution
            current_energy = new_energy

        if new_energy < best_energy:
            best_solution = new_solution
            best_energy = new_energy

        temperature *= cooling_rate

    return best_solution, best_energy

if __name__ == "__main__":
    file_path = "/content/1000_euclidianDistance - Copy.txt"  # Replace with the actual path to your dataset file
    dataset = read_data(file_path)

    num_cities = max(max(x[0], x[1]) for x in dataset)
    distances = np.zeros((num_cities, num_cities))

    for entry in dataset:
        distances[entry[0] - 1, entry[1] - 1] = entry[2]

    best_tour, best_distance = simulated_annealing(distances)

num_runs = 100  # You can adjust the number of runs as needed

best_solution = None
best_distance = float('inf')

for _ in range(num_runs):
    current_solution, current_distance = simulated_annealing(distances)

    if current_distance < best_distance:
        best_solution = current_solution
        best_distance = current_distance

print("Best Tour:", best_solution)
print("Best Distance:", best_distance)

import numpy as np
import random
import math

def read_data(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()

    data = []
    for line in lines:
        parts = line.split()
        data.append((int(parts[0]), int(parts[1]), float(parts[2])))
    return data


def calculate_total_distance(tour, distances):
    total_distance = 0
    for i in range(len(tour) - 1):
        total_distance += distances[tour[i] - 1, tour[i + 1] - 1]
    total_distance += distances[tour[-1] - 1, tour[0] - 1]  # Return to the starting city
    return total_distance

def generate_initial_solution(num_cities):
    return list(range(1, num_cities + 1))

def get_neighbor_solution(current_solution):
    neighbor_solution = current_solution.copy()
    rand1, rand2 = random.sample(range(len(current_solution)), 2)
    neighbor_solution[rand1], neighbor_solution[rand2] = neighbor_solution[rand2], neighbor_solution[rand1]
    return neighbor_solution

def acceptance_probability(current_energy, new_energy, temperature):
    if new_energy < current_energy:
        return 1.0
    return math.exp((current_energy - new_energy) / temperature)

def simulated_annealing(distances, initial_temperature=1000, cooling_rate=0.99, iterations=10000):
    num_cities = len(distances)
    current_solution = generate_initial_solution(num_cities)
    current_energy = calculate_total_distance(current_solution, distances)

    best_solution = current_solution
    best_energy = current_energy

    temperature = initial_temperature

    for _ in range(iterations):
        new_solution = get_neighbor_solution(current_solution)
        new_energy = calculate_total_distance(new_solution, distances)

        if acceptance_probability(current_energy, new_energy, temperature) > random.random():
            current_solution = new_solution
            current_energy = new_energy

        if new_energy < best_energy:
            best_solution = new_solution
            best_energy = new_energy

        temperature *= cooling_rate

    return best_solution, best_energy

if __name__ == "__main__":
    file_path = "/content/1000_randomDistance - Copy.txt"  # Replace with the actual path to your dataset file
    dataset = read_data(file_path)

    num_cities = max(max(x[0], x[1]) for x in dataset)
    distances = np.zeros((num_cities, num_cities))

    for entry in dataset:
        distances[entry[0] - 1, entry[1] - 1] = entry[2]

    best_tour, best_distance = simulated_annealing(distances)

num_runs = 100  # You can adjust the number of runs as needed

best_solution = None
best_distance = float('inf')

for _ in range(num_runs):
    current_solution, current_distance = simulated_annealing(distances)

    if current_distance < best_distance:
        best_solution = current_solution
        best_distance = current_distance

print("Best Tour:", best_solution)
print("Best Distance:", best_distance)